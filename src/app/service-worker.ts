/// <reference lib="webworker" />

import { clientsClaim } from 'workbox-core'
import { ExpirationPlugin } from 'workbox-expiration'
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies'
import { CacheableResponsePlugin } from 'workbox-cacheable-response'

declare const self: ServiceWorkerGlobalScope

// Version for cache management
const CACHE_VERSION = '1.0.0'
const APP_CACHE_NAME = `mosaic-app-${CACHE_VERSION}`
const IMAGE_CACHE_NAME = `mosaic-images-${CACHE_VERSION}`
const API_CACHE_NAME = `mosaic-api-${CACHE_VERSION}`

// Claim clients immediately
clientsClaim()

// Skip waiting on install
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }
})

// Precache all assets generated by your build process
// This uses the __WB_MANIFEST variable injected by workbox-webpack-plugin
precacheAndRoute(self.__WB_MANIFEST)

// Set up App Shell-style routing
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$')
registerRoute(
  // Return false for URLs that should not be handled by the App Shell
  ({ request, url }: { request: Request; url: URL }) => {
    // If this is a request for a static asset, let the precache handle it
    if (request.mode !== 'navigate') {
      return false
    }

    // If this is a URL that starts with /_, skip
    if (url.pathname.startsWith('/_')) {
      return false
    }

    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false
    }

    // Return true to signal that we want to use the handler
    return true
  },
  createHandlerBoundToURL(`${process.env.PUBLIC_URL}/index.html`)
)

// Cache thumbnail images with a Cache First strategy
registerRoute(
  ({ request, url }) => {
    return request.destination === 'image' && 
           (url.pathname.includes('/thumbnails/') || url.pathname.includes('/exercises/'));
  },
  new CacheFirst({
    cacheName: IMAGE_CACHE_NAME,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100, // Limit number of cached images
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        purgeOnQuotaError: true, // Automatically cleanup if storage quota is exceeded
      }),
    ],
  })
)

// Cache other images with a Stale While Revalidate strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new StaleWhileRevalidate({
    cacheName: IMAGE_CACHE_NAME,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
        purgeOnQuotaError: true,
      }),
    ],
  })
)

// Cache API responses with a Network First strategy
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: API_CACHE_NAME,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60, // 1 day
        purgeOnQuotaError: true,
      }),
    ],
  })
)

// Cache CSS, JS, and Web Worker with a Stale While Revalidate strategy
registerRoute(
  ({ request }) => 
    request.destination === 'style' || 
    request.destination === 'script' || 
    request.destination === 'worker',
  new StaleWhileRevalidate({
    cacheName: APP_CACHE_NAME,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
)

// Clean up old caches on activation
self.addEventListener('activate', (event) => {
  const currentCaches = [APP_CACHE_NAME, IMAGE_CACHE_NAME, API_CACHE_NAME];
  
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (!currentCaches.includes(cacheName)) {
            console.log('Deleting out of date cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

// Special handling for offline fallbacks
self.addEventListener('fetch', (event) => {
  // Only handle GET requests
  if (event.request.method !== 'GET') return

  // Handle specific API requests that should work offline
  if (event.request.url.includes('/api/routines') || 
      event.request.url.includes('/api/exercises')) {
    event.respondWith(
      fetch(event.request)
        .catch(() => {
          // If the network request fails, try to serve from IndexedDB
          // This is handled by our application code, so we return a
          // response that signals the app to use local data
          return new Response(
            JSON.stringify({ offline: true, message: 'Using offline data' }),
            {
              headers: { 'Content-Type': 'application/json' },
              status: 200
            }
          )
        })
    )
  }
})

// Sync manager for handling background sync
self.addEventListener('sync', (event: any) => {
  if (event.tag === 'sync-routines') {
    event.waitUntil(syncRoutines())
  }
})

// Function to sync routines when back online
async function syncRoutines() {
  try {
    // Get all pending sync requests from IndexedDB
    const db = await openDB('mosaic-sync-queue', 1)
    const tx = db.transaction('sync-requests', 'readwrite')
    const store = tx.objectStore('sync-requests')
    const getAllRequest = store.getAll()
    const requests = await new Promise<any[]>((resolve, reject) => {
      getAllRequest.onsuccess = () => resolve(getAllRequest.result)
      getAllRequest.onerror = () => reject(getAllRequest.error)
    })
    // Process each request
    for (const request of requests) {
      try {
        // Attempt to sync with the server
        const response = await fetch(request.url, {
          method: request.method,
          headers: request.headers,
          body: request.body ? JSON.stringify(request.body) : undefined
        })
        // Handle response as needed
      } catch (error: any) {
        // Handle individual sync error
        console.error('Sync error:', error.message || error)
      }
    }
    // Notify the application that sync is complete
    const clients = await self.clients.matchAll()
    for (const client of clients) {
      client.postMessage({
        type: 'SYNC_COMPLETED',
        success: true
      })
    }
  } catch (error: any) {
    console.error('Sync routines failed:', error.message || error)
    
    // Notify the application that sync failed
    const clients = await self.clients.matchAll()
    for (const client of clients) {
      client.postMessage({
        type: 'SYNC_COMPLETED',
        success: false,
        error: error.message || error
      })
    }
  }
}

// Helper function to open IndexedDB
function openDB(name: string, version: number) {
  return new Promise<IDBDatabase>((resolve, reject) => {
    const request = indexedDB.open(name, version)
    
    request.onerror = () => reject(request.error)
    request.onsuccess = () => resolve(request.result)
    
    request.onupgradeneeded = (event) => {
      const db = request.result
      if (!db.objectStoreNames.contains('sync-requests')) {
        db.createObjectStore('sync-requests', { keyPath: 'id' })
      }
    }
  })
}
